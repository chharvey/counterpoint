type ProductionData = [
	name: Text,
	defn: ChoiceData,
];
type ChoiceData = NonemptySequence<NonemptySequence<
	| Text
	| [term: Text]
	| [prod: Text]
>>;



ChoiceData Transform(SemanticItem expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is at least 1.
	2. *Let* `operand` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `i` be 1.
	4. *While* `i` is less than `expr.children.count`:
		1. *If* `expr.children[i].include` is TRUE *and* `nt` contains the suffix `expr.children[i].name`:
			1. *Return:* `operand`.
		2. *If* `expr.children[i].include` is FALSE *and* `nt` does not contain the suffix `expr.children[i].name`:
			1. *Return:* `operand`.
		3. Increment `i`.
	5. *Return:* [[""]].
;



ChoiceData Transform(SemanticOp[operator: PLUS] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `newname` be the concatenation of `nt` with "__‹n›__List", where ‹n› is a unique number.
	4. *Let* `flatmap` be a flattened mapping from `operand` indexed by `i` to [
			[                 ...operand[i]],
			[[prod= newname], ...operand[i]],
		].
	5. Push [
			name= newname,
			defn= flatmap,
		] to `prods`.
	6. *Return:* [
		[[prod= newname]],
	].
;

ChoiceData Transform(SemanticOp[operator: STAR] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `newname` be the concatenation of `nt` with "__‹n›__List", where ‹n› is a unique number.
	4. *Let* `flatmap` be a flattened mapping from `operand` indexed by `i` to [
			[                 ...operand[i]],
			[[prod= newname], ...operand[i]],
		].
	5. Push [
			name= newname,
			defn= flatmap,
		] to `prods`.
	6. *Return:* [
		[""],
		[[prod= newname]],
	].
;

ChoiceData Transform(SemanticOp[operator: HASH] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `newname` be the concatenation of `nt` with "__‹n›__List", where ‹n› is a unique number.
	4. *Let* `flatmap` be a flattened mapping from `operand` indexed by `i` to [
			[                      ...operand[i]],
			[[prod= newname], ",", ...operand[i]],
		].
	5. Push [
			name= newname,
			defn= flatmap,
		] to `prods`.
	6. *Return:* [
		[[prod= newname]],
	].
;

ChoiceData Transform(SemanticOp[operator: OPT] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Return:* [
		[""],
		...operand,
	].
;

ChoiceData Transform(SemanticOp[operator: ORDER] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `operand1` be *UnwrapAffirm:* Transform(expr.children.1, nt, data).
	4. *Return:* a flattened mapping from `operand0` indexed by `i` to
		a flattened mapping from `operand1` indexed by `j` to [
			[...operand0[i]],
			[...operand1[j]],
		].
;

ChoiceData Transform(SemanticOp[operator: CONCAT] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `operand1` be *UnwrapAffirm:* Transform(expr.children.1, nt, data).
	4. *Return:* a flattened mapping from `operand0` indexed by `i` to
		a flattened mapping from `operand1` indexed by `j` to [
			[...operand0[i], ...operand1[j]],
			[...operand1[j], ...operand0[i]],
		].
;

ChoiceData Transform(SemanticOp[operator: ALTERN] expr, Text nt, Sequence<ProductionData> data) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *UnwrapAffirm:* Transform(expr.children.0, nt, data).
	3. *Let* `operand1` be *UnwrapAffirm:* Transform(expr.children.1, nt, data).
	4. *Return:* a flattened mapping from `operand0` indexed by `i` to
		a flattened mapping from `operand1` indexed by `j` to [
			[...operand0[i], ...operand1[j]],
		].
;



Sequence<Text> Transform(SemanticNonterminal nt) :=
	1. *Let* `power_suffix` be the power sequence of `nt.children`, preserving order.
		1. *Note:* A “power set” is the set of all subsets of a set.
			For example, the power set of `["a", "b", "c"]` is
			`[[], ["a"], ["b"], ["c"], ["a", "b"], ["a", "c"], ["b", "c"], ["a", "b", "c"]]`.
			A “power sequence” is the ordered analog of a power set, wherein order is preserved,
			i.e., the sequence `["a", "b"]` is not the same as the sequence `["b", "a"]`.
	2. *Let* `names` be an empty sequence.
	3. *For* `i` in `power_suffix`:
		1. *Let* `suffix` be a mapping from `power_suffix[i]` indexed by `j` to `power_suffix[i][j].name`.
		2. *Set* `suffix` to the concatenation of each element of `suffix`, separated by "_".
		3. *Let* `name` be the concatenation of `nt.name` with `suffix`.
		4. *Push* `name` to `names`.
	4. *Return:* `names`.
;



Sequence<ProductionData> Transform(SemanticProduction prod) :=
	1. *Assert:* `prod.children.count` is 2.
	2. *Let* `prods` be an empty sequence.
	3. *Let* `names` be *UnwrapAffirm:* `Transform(prod.children.0)`
	4. *Let* `defn` be *UnwrapAffirm:* `Transform(prod.children.1, names[i], prods)`.
	5. *Set* `prods` to a mapping from `names` indexed by `i` to [name= names[i], defn= defn].
	6. *Return:* `prods`.
;



Sequence<ProductionData> Transform(SemanticGrammar grammar) :=
	1. *Return:* `Transform(grammar.children)`.
;
