Sequence<Instruction> Build(Null n) :=
	1. *Return:* ["Push `0` onto the operand stack."].

Sequence<Instruction> Build(Boolean b) :=
	1. *If* `b` is `true`:
		1. *Return:* ["Push `1` onto the operand stack."].
	2. *Assert:* `b` is `false`.
	3. *Return:* ["Push `0` onto the operand stack."].

Sequence<Instruction> Build(Or<Integer, Float> n) :=
	1. *Return:* ["Push `n` onto the operand stack."].

Sequence<Instruction> Build(SemanticConstant const) :=
	1. *Return:* `Build(Assess(const))`.

Sequence<Instruction> Build(SemanticIdentifier iden) :=
	/* TO BE DETERMINED */

Void Build(SemanticTemplate tpl) :=
	/* TO BE DETERMINED */



Sequence<Instruction> Build(SemanticOperation[operator: NOT | EMPTY | NEG] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `instrs` be the result of performing `TryAssessAndBuild(expr.children.0)`.
	3. *Return:* [
		...instrs,
		"`expr.operator`",
	].



Sequence<Instruction> Build(SemanticOperation[operator: EXP | MUL | DIV | ADD] expr) :=
	1. *Let* `builds` be `PrebuildSemanticOperationBinary(expr)`.
	2. *Return:* [
		...builds.0,
		...builds.1,
		"`expr.operator`",
	].



Sequence<Instruction> Build(SemanticOperation[operator: AND] expr) :=
	1. *Let* `builds` be `PrebuildSemanticOperationBinary(expr)`.
	2. *Return:* [
		...builds.0,
		"TEE the local variable `operand0`.",
		"NOT",
		"NOT",
		"IF",
		...builds.1,
		"ELSE",
		"GET the local variable `operand0`.",
		"END",
	].



Sequence<Instruction> Build(SemanticOperation[operator: OR] expr) :=
	1. *Let* `builds` be `PrebuildSemanticOperationBinary(expr)`.
	2. *Return:* [
		...builds.0,
		"TEE the local variable `operand0`.",
		"NOT",
		"NOT",
		"IF",
		"GET the local variable `operand0`.",
		"ELSE",
		...builds.1,
		"END",
	].



Sequence<Instruction> Build(SemanticOperation[operator: COND] expr) :=
	1. *Assert:* `expr.children.count` is 3.
	2. *Let* `instrs0` be the result of performing `TryAssessAndBuild(expr.children.0)`.
	3. *Let* `instrs1` be the result of performing `TryAssessAndBuild(expr.children.1)`.
	4. *Let* `instrs2` be the result of performing `TryAssessAndBuild(expr.children.2)`.
	5. *Return:* [
		...instrs0,
		"IF",
		...instrs1,
		"ELSE",
		...instrs2,
		"END",
	].



Sequence<Instruction> Build(SemanticStatementExpression stmt) :=
	1. *Let* `sequence` be an empty sequence of `Instruction`s.
	2. *If* `stmt.children.count` is greater than 0:
		1. *Set* `sequence` to the result of performing `TryAssessAndBuild(stmt.children.0)`.
	3. *Return* `sequence`.



Sequence<Instruction> Build(SemanticDeclaration decl) :=
	/* TO BE DETERMINED */

Sequence<Instruction> Build(SemanticAssignment assign) :=
	/* TO BE DETERMINED */



Sequence<Instruction> Build(SemanticGoal goal) :=
	1. *Let* `sequence` be an empty sequence of `Instruction`s.
	2. For each `SemanticStatment stmt` in `goal.children`:
		1. *Let* `instrs` be the result of performing `Build(stmt)`.
		2. Push `...instrs` to `sequence`.
	3. *Return* `sequence`.
