Or<Null, Boolean, Integer, Float> Assess(SemanticConstant const) :=
	1. *Return:* `const.value`.

Unknown Assess(SemanticIdentifier iden) :=
	// TO BE DETERMINED

Void Assess(SemanticTemplate tpl) :=
	// TO BE DETERMINED



Boolean? Assess(SemanticOperation[operator: NOT] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand)` is `Void`:
		1. *Return*.
	4. *Let* `is_truthy` be the result of performing `ToBoolean(operand)`.
	5. *If* `is_truthy` is `true`:
		1. *Return:* `false`.
	6. *Return:* `true`.

Boolean? Assess(SemanticOperation[operator: EMP] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand)` is `Void`:
		1. *Return*.
	4. *Let* `is_truthy` be the result of performing `ToBoolean(operand)`.
	5. *If* `is_truthy` is `false`:
		1. *Return:* `true`.
	6. *If* `TypeOf(operand)` is `Integer` *and* `operand` is `0`:
		1. *Return:* `true`.
	7. *If* `TypeOf(operand)` is `Float` *and* `operand` is `0.0` or `-0.0`:
		1. *Return:* `true`.
	8. *Return:* `false`.

Or<Integer, Float>? Assess(SemanticOperation[operator: NEG] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand)` is `Void`:
		1. *Return*.
	4. *Assert:* `IsNumeric(operand)` is `true`.
	5. *Let* `negation` be the additive inverse, `-operand`,
		obtained by negating `operand`.
	6. *Return:* `negation`.



Or<Integer, Float>? Assess(SemanticOperation[operator: EXP | MUL | DIV | ADD] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand0)` is `Void`:
		1. *Return*.
	4. *Let* `operand1` be the result of performing `Assess(expr.children.1)`.
	5. *If* `TypeOf(operand1)` is `Void`:
		1. *Return*.
	6. *Assert*: `IsNumeric(TypeOf(operand0))` *and* `IsNumeric(TypeOf(operand1))`.
	7. *If* `TypeOf(operand0)` is `Integer` *and* `TypeOf(operand1)` is `Integer`:
		1. *Return:* `Integer(PerformBinaryArithmetic(expr.operator, operand0, operand1))`.
	8. *Return:* `Float(PerformBinaryArithmetic(expr.operator, Float(float0), Float(float1)))`.



Boolean? Assess(SemanticOperation[operator: LT | GT | LE | GE] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand0)` is `Void`:
		1. *Return*.
	4. *Let* `operand1` be the result of performing `Assess(expr.children.1)`.
	5. *If* `TypeOf(operand1)` is `Void`:
		1. *Return*.
	6. *Assert*: `IsNumeric(TypeOf(operand0))` *and* `IsNumeric(TypeOf(operand1))`.
	7. *If* `TypeOf(operand0)` is `Integer` *and* `TypeOf(operand1)` is `Integer`:
		1. *Return:* `PerformBinaryCompare(expr.operator, operand0, operand1)`.
	8. *Return:* `PerformBinaryCompare(expr.operator, Float(float0), Float(float1))`.



Boolean? Assess(SemanticOperation[operator: ID] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand0)` is `Void`:
		1. *Return*.
	4. *Let* `operand1` be the result of performing `Assess(expr.children.1)`.
	5. *If* `TypeOf(operand1)` is `Void`:
		1. *Return*.
	6. *Return:* `Identical(operand0, operand1)`.

Boolean? Assess(SemanticOperation[operator: EQ] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand0)` is `Void`:
		1. *Return*.
	4. *Let* `operand1` be the result of performing `Assess(expr.children.1)`.
	5. *If* `TypeOf(operand1)` is `Void`:
		1. *Return*.
	6. *Return:* `Equal(operand0, operand1)`.



Or<Null, Boolean, Integer, Float>? Assess(SemanticOperation[operator: AND] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand0)` is `Void`:
		1. *Return*.
	4. *If* `ToBoolean(operand0)` is `false`:
		1. *Return:* `operand0`.
	5. *Return:* `Assess(expr.children.1)`.



Or<Null, Boolean, Integer, Float>? Assess(SemanticOperation[operator: OR] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(operand0)` is `Void`:
		1. *Return*.
	4. *If* `ToBoolean(operand0)` is `true`:
		1. *Return:* `operand0`.
	5. *Return:* `Assess(expr.children.1)`.



Or<Null, Boolean, Integer, Float>? Assess(SemanticOperation[operator: COND] expr) :=
	1. *Assert:* `expr.children.count` is 3.
	2. *Let* `condition` be the result of performing `Assess(expr.children.0)`.
	3. *If* `TypeOf(condition)` is `Void`:
		1. *Return*.
	4. *Assert:* `TypeOf(condition)` is `Boolean`.
	5. *If* `condition` is `true`:
		1. *Return:* `Assess(expr.children.1)`.
	6. *Else:*
		1. *Return:* `Assess(expr.children.2)`.
