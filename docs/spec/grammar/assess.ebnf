Type Assess(SemanticTypeConstant const) :=
	1. *Return:* `const.value`.
;



Type Assess(SemanticTypeAlias var) :=
	1. *If* the validator’s symbol table contains a SymbolStructure `symbol` whose `id` is `var.id`:
		1. *Assert:* `symbol` is an instance of `SymbolStructureType`.
		2. *Assert:* `symbol.value` is a Solid Language Type.
		3. *Return:* `symbol.value`.
	2. *Return:* `Unknown`.
;


Type Assess(SemanticTypeTuple tupletype) :=
	1. *Let* `data` be a mapping of `tupletype` for each `type` to *UnwrapAffirm:* `Assess(type)`.
	2. *Return:* a subtype of `Tuple` whose items are `data`.
;



Type Assess(SemanticTypeRecord recordtype) :=
	1. *Let* `data` be a new Structure.
	2. *For each* `propertytype` in `recordtype`:
		1. Set `data` to [
			...data,
			`propertytype.children.0.id`= *UnwrapAffirm:* `Assess(propertytype.children.1)`,
		].
	3. *Return:* a subtype of `Record` whose properties are `data`.
;



Type Assess(SemanticTypeOperation[operator: ORNULL] oper) :=
	1. *Assert:* `oper.children.count` is 1.
	2. *Let* `child` be *UnwrapAffirm:* `Assess(oper.children.0)`.
	3. *Return:* `Union(child, Null)`.
;

Type Assess(SemanticTypeOperation[operator: AND] oper) :=
	1. *Assert:* `oper.children.count` is 2.
	2. *Let* `child0` be *UnwrapAffirm:* `Assess(oper.children.0)`.
	3. *Let* `child1` be *UnwrapAffirm:* `Assess(oper.children.1)`.
	4. *Return:* `Intersection(child0, child1)`.
;

Type Assess(SemanticTypeOperation[operator: OR] oper) :=
	1. *Assert:* `oper.children.count` is 2.
	2. *Let* `child0` be *UnwrapAffirm:* `Assess(oper.children.0)`.
	3. *Let* `child1` be *UnwrapAffirm:* `Assess(oper.children.1)`.
	4. *Return:* `Union(child0, child1)`.
;



Or<Null, Boolean, Number, String> Assess(SemanticConstant const) :=
	1. *Return:* `const.value`.
;



Object! Assess(SemanticVariable var) :=
	1. *If* the validator’s symbol table contains a SymbolStructure `symbol` whose `id` is `var.id`:
		1. *Assert:* `symbol` is an instance of `SymbolStructureVar`.
		2. *If* `symbol.unfixed` is `false`:
			1. *Assert:* `symbol.value` is a Completion Structure.
			2. *Return:* `symbol.value`.
	2. *Throw:* `void`.
;



String! Assess(SemanticTemplate tpl) :=
	1. *Let* `values` be a mapping for each `node` in `tpl.children` to *Unwrap:* `Assess(node)`.
	2. *Let* `strings` be a mapping for each `value` in `values` to `ToString(value)`.
	3. *Return:* the string-concatenation of each item in `strings`, preserving order.
;



Tuple! Assess(SemanticTuple tuple) :=
	1. *Let* `data` be a mapping of `tuple` for each `it` to `Assess(it)`.
	2. *For index* `i` in `data`:
		1. *If* `data[i]` is a normal completion:
			1. *Set* `data[i]` to `data[i].value`.
	3. *If* `data` contains a CompletionStructure `err`:
		1. *Assert:* `err` is an abrupt completion.
		2. *Return:* `err`.
	4. *Return:* a new Tuple containing the items in the sequence `data`.
;



Record! Assess(SemanticRecord record) :=
	1. *Let* `data` be a new Structure.
	2. *For each* `property` in `record`:
		1. Set `data` to [
			...data,
			`property.children.0.id`= `Assess(property.children.1)`,
		].
	3. *For key* `k` in `data`:
		1. *If* `data[k]` is a normal completion:
			1. *Set* `data[k]` to `data[k].value`.
	4. *If* `data` contains a property whose value is a CompletionStructure `err`:
		1. *Assert:* `err` is an abrupt completion.
		2. *Return:* `err`.
	5. *Return:* a new Record containing the properties in the structure `data`.
;



Mapping! Assess(SemanticMapping mapping) :=
	1. *Let* `data` be a mapping of `mapping` for each `case` to a new Sequence [
		`Assess(case.children.0)`,
		`Assess(case.children.1)`,
	].
	2. *For each* `it` in `data`:
		1. *Assert:* `it.count` is 2.
		2. *If* `it.0` is a normal completion:
			1. *Set* `it.0` to `it.0.value`.
		3. *If* `it.1` is a normal completion:
			1. *Set* `it.1` to `it.1.value`.
	3. *If* `data` contains a 2-tuple that contains a CompletionStructure `err`:
		1. *Assert:* `err` is an abrupt completion.
		2. *Return:* `err`.
	4. *Return:* a new Mapping containing the pairs in the sequence `data`.
;



Boolean! Assess(SemanticOperation[operator: NOT] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *Unwrap:* `Assess(expr.children.0)`.
	3. *If* *UnwrapAffirm:* `ToBoolean(operand)` is `true`:
		1. *Return:* `false`.
	4. *Return:* `true`.
;

Boolean! Assess(SemanticOperation[operator: EMP] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *Unwrap:* `Assess(expr.children.0)`.
	3. *If* *UnwrapAffirm:* `ToBoolean(operand)` is `false`:
		1. *Return:* `true`.
	4. *If* `operand` is an instance of `Integer` *and* `operand` is `0`:
		1. *Return:* `true`.
	5. *If* `operand` is an instance of `Float` *and* `operand` is `0.0` or `-0.0`:
		1. *Return:* `true`.
	6. *If* `operand` is an instance of `String` *and* `operand` contains 0 codepoints:
		1. *Return:* `true`.
	7. *Return:* `false`.
;

Number! Assess(SemanticOperation[operator: NEG] expr) :=
	1. *Assert:* `expr.children.count` is 1.
	2. *Let* `operand` be *Unwrap:* `Assess(expr.children.0)`.
	3. *Assert:* `operand` is an instance of `Number`.
	4. *Let* `negation` be the additive inverse, `-operand`,
		obtained by negating `operand`.
	5. *Return:* `negation`.
;

Number! Assess(SemanticOperation[operator: EXP | MUL | DIV | ADD] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *Unwrap:* `Assess(expr.children.0)`.
	3. *Let* `operand1` be *Unwrap:* `Assess(expr.children.1)`.
	4. *Assert*: `operand0` is an instance of `Number` *and* `operand1` is an instance of `Number`.
	5. *If* `operand0` is an instance of `Integer` *and* `operand1` is an instance of `Integer`:
		1. *Return:* `Integer(*UnwrapAffirm:* PerformBinaryArithmetic(expr.operator, operand0, operand1))`.
	6. *Return:* `Float(*UnwrapAffirm:* PerformBinaryArithmetic(expr.operator, Float(operand0), Float(operand1)))`.
;

Boolean! Assess(SemanticOperation[operator: LT | GT | LE | GE] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *Unwrap:* `Assess(expr.children.0)`.
	3. *Let* `operand1` be *Unwrap:* `Assess(expr.children.1)`.
	4. *Assert*: `operand0` is an instance of `Number` *and* `operand1` is an instance of `Number`.
	5. *If* `operand0` is an instance of `Integer` *and* `operand1` is an instance of `Integer`:
		1. *Return:* `PerformBinaryCompare(expr.operator, operand0, operand1)`.
	6. *Return:* `PerformBinaryCompare(expr.operator, Float(float0), Float(float1))`.
;

Boolean! Assess(SemanticOperation[operator: IS] expr) :=
	1. *Throw:* new TypeError "Operator not yet supported.".
;

Boolean! Assess(SemanticOperation[operator: ID] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *Unwrap:* `Assess(expr.children.0)`.
	3. *Let* `operand1` be *Unwrap:* `Assess(expr.children.1)`.
	4. *Assert*: Neither `operand0` nor `operand1` is `void`.
	5. *Return:* `Identical(operand0, operand1)`.
;

Boolean! Assess(SemanticOperation[operator: EQ] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *Unwrap:* `Assess(expr.children.0)`.
	3. *Let* `operand1` be *Unwrap:* `Assess(expr.children.1)`.
	4. *Assert*: Neither `operand0` nor `operand1` is `void`.
	5. *Return:* `Equal(operand0, operand1)`.
;

Object! Assess(SemanticOperation[operator: AND] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *Unwrap:* `Assess(expr.children.0)`.
	3. *If* *UnwrapAffirm:* `ToBoolean(operand0)` is `false`:
		1. *Return:* `operand0`.
	4. *Return:* `Assess(expr.children.1)`.
;

Object! Assess(SemanticOperation[operator: OR] expr) :=
	1. *Assert:* `expr.children.count` is 2.
	2. *Let* `operand0` be *Unwrap:* `Assess(expr.children.0)`.
	3. *If* *UnwrapAffirm:* `ToBoolean(operand0)` is `true`:
		1. *Return:* `operand0`.
	4. *Return:* `Assess(expr.children.1)`.
;

Object! Assess(SemanticOperation[operator: COND] expr) :=
	1. *Assert:* `expr.children.count` is 3.
	2. *Let* `condition` be *Unwrap:* `Assess(expr.children.0)`.
	3. *Assert:* `condition` is an instance of `Boolean`.
	4. *If* `condition` is `true`:
		1. *Return:* `Assess(expr.children.1)`.
	5. *Else:*
		1. *Return:* `Assess(expr.children.2)`.
;
