// KEYWORD_TYPE    ::= [./lexicon.ebnf#KeywordType];
// KEYWORD_VALUE   ::= [./lexicon.ebnf#KeywordValue];
// IDENTIFIER      ::= [./lexicon.ebnf#Identifier];
// INTEGER         ::= [./lexicon.ebnf#Integer];
// FLOAT           ::= [./lexicon.ebnf#Float];
// STRING          ::= [./lexicon.ebnf#String];
// TEMPLATE_FULL   ::= [./lexicon.ebnf#TemplateFull];
// TEMPLATE_HEAD   ::= [./lexicon.ebnf#TemplateHead];
// TEMPLATE_MIDDLE ::= [./lexicon.ebnf#TempalteMiddle];
// TEMPLATE_TAIL   ::= [./lexicon.ebnf#TempalteTail];



Word ::=
	// operator
		| "mutable"
		| "is"
		| "isnt"
		| "if"
		| "then"
		| "else"
	// storage
		| "type"
		| "let"
	// modifier
		| "unfixed"
	| KEYWORD_TYPE
	| KEYWORD_VALUE
	| IDENTIFIER
;



PrimitiveLiteral ::=
	| KEYWORD_VALUE
	| INTEGER
	| FLOAT
	| STRING
;



EntryType<Named, Optional, Variable>
	::= <Named+>(Word . <Optional->":") <Optional+>"?:" Type<?Variable>;

ItemsType<Variable> ::=
	|  EntryType<-Named><-Optional><?Variable># ","?
	| (EntryType<-Named><-Optional><?Variable># ",")? EntryType<-Named><+Optional><?Variable># ","?
;

PropertiesType<Variable>
	::= EntryType<+Named><-Optional, +Optional><?Variable># ","?;

TypeGrouped       <Variable> ::=                            "(" Type<?Variable>                      ")";
TypeTupleLiteral  <Variable> ::= <Variable->"\[" <Variable+>"[" (","? ItemsType<?Variable>)?         "]";
TypeRecordLiteral <Variable> ::= <Variable->"\[" <Variable+>"["  ","? PropertiesType<?Variable>      "]";
TypeDictLiteral              ::=                            "[" ":" Type<+Variable>                  "]";
TypeMapLiteral               ::=                            "{" Type<+Variable> "->" Type<+Variable> "}";
GenericArguments             ::=                            "<"  ","? Type<+Variable># ","?          ">";

TypeUnit<Variable> ::=
	| KEYWORD_TYPE
	| <Variable+>IDENTIFIER
	| PrimitiveLiteral
	| TypeGrouped       <?Variable>
	| TypeTupleLiteral  <-Variable>
	| TypeRecordLiteral <-Variable>
	| <Variable+>TypeTupleLiteral  <?Variable>
	| <Variable+>TypeRecordLiteral <?Variable>
	| <Variable+>TypeDictLiteral
	| <Variable+>TypeMapLiteral
;

PropertyAccessType ::= "." (INTEGER | Word);
GenericCall        ::= "." GenericArguments;

TypeCompound<Variable> ::=
	| TypeUnit<?Variable>
	| TypeCompound<?Variable> PropertyAccessType
	| <Variable+>(TypeCompound<?Variable> GenericCall)
;

TypeUnarySymbol<Variable> ::=
	| TypeCompound<?Variable>
	| TypeUnarySymbol<?Variable> (
		| "?"
		| "!"
		| "\[" INTEGER "]"
		| <Variable+>("[" INTEGER? "]")
		| <Variable+>("{" "}")
	)
;

TypeUnaryKeyword<Variable> ::=
	| TypeUnarySymbol<?Variable>
	| "mutable" TypeUnaryKeyword<?Variable>
;

TypeIntersection <Variable> ::= (TypeIntersection <?Variable> "&")? TypeUnaryKeyword<?Variable>;
TypeUnion        <Variable> ::= (TypeUnion        <?Variable> "|")? TypeIntersection<?Variable>;

Type<Variable> ::=
	| TypeUnion<?Variable>
;



StringTemplate<Variable> ::=
	| TEMPLATE_FULL
	| TEMPLATE_HEAD Expression<?Variable>? (TEMPLATE_MIDDLE Expression<?Variable>?)* TEMPLATE_TAIL
;

Property <Variable> ::= Word                  "="  Expression<?Variable>;
Case                ::= Expression<+Variable> "->" Expression<+Variable>;

ExpressionGrouped <Variable> ::=                            "("        Expression <?Variable>          ")";
TupleLiteral      <Variable> ::= <Variable->"\[" <Variable+>"[" ( ","? Expression <?Variable># ","? )? "]";
RecordLiteral     <Variable> ::= <Variable->"\[" <Variable+>"["   ","? Property   <?Variable># ","?    "]";
SetLiteral                   ::=                            "{" ( ","? Expression <+Variable># ","? )? "}";
MapLiteral                   ::=                            "{"   ","? Case#                   ","?    "}";
FunctionArguments            ::=                            "(" ( ","? Expression <+Variable># ","? )? ")";

ExpressionUnit<Variable> ::=
	| <Variable+>IDENTIFIER
	| PrimitiveLiteral
	| StringTemplate    <?Variable>
	| ExpressionGrouped <?Variable>
	| TupleLiteral      <-Variable>
	| RecordLiteral     <-Variable>
	| <Variable+>TupleLiteral  <?Variable>
	| <Variable+>RecordLiteral <?Variable>
	| <Variable+>SetLiteral
	| <Variable+>MapLiteral
;

PropertyAccess<Variable> ::= ("." | "?." | "!.") (INTEGER | Word | "[" Expression<?Variable> "]");
PropertyAssign           ::=  "."                (INTEGER | Word | "[" Expression<+Variable> "]");
FunctionCall             ::=  "."                GenericArguments? FunctionArguments;

ExpressionCompound<Variable> ::=
	| ExpressionUnit<?Variable>
	| ExpressionCompound<?Variable> PropertyAccess<?Variable>
	| <Variable+>(ExpressionCompound<?Variable> FunctionCall)
;

Assignee ::=
	| IDENTIFIER
	| ExpressionCompound<+Variable> PropertyAssign
;

ExpressionUnarySymbol<Variable> ::=
	| ExpressionCompound<?Variable>
	| ("!" | "?" | "+" | "-") ExpressionUnarySymbol<?Variable>
;

ExpressionExponential<Variable>
	::= ExpressionUnarySymbol<?Variable> ("^" ExpressionExponential<?Variable>)?;

ExpressionMultiplicative <Variable> ::= (ExpressionMultiplicative <?Variable> ("*" | "/" ))?                                            ExpressionExponential    <?Variable>;
ExpressionAdditive       <Variable> ::= (ExpressionAdditive       <?Variable> ("+" | "-" ))?                                            ExpressionMultiplicative <?Variable>;
ExpressionComparative    <Variable> ::= (ExpressionComparative    <?Variable> ("<" | ">" | "<=" | ">=" | "!<" | "!>" | "is" | "isnt"))? ExpressionAdditive       <?Variable>;
ExpressionEquality       <Variable> ::= (ExpressionEquality       <?Variable> ("===" | "!==" | "==" | "!="))?                           ExpressionComparative    <?Variable>;
ExpressionConjunctive    <Variable> ::= (ExpressionConjunctive    <?Variable> ("&&" | "!&"))?                                           ExpressionEquality       <?Variable>;
ExpressionDisjunctive    <Variable> ::= (ExpressionDisjunctive    <?Variable> ("||" | "!|"))?                                           ExpressionConjunctive    <?Variable>;

ExpressionConditional<Variable>
	::= "if" Expression<?Variable> "then" Expression<?Variable> "else" Expression<?Variable>;

Expression<Variable> ::=
	| ExpressionDisjunctive<?Variable>
	| ExpressionConditional<?Variable>
;



DeclarationType     ::= "type"            IDENTIFIER "=" Type<+Variable>                           ";";
DeclarationVariable ::= "let"  "unfixed"? IDENTIFIER ":" Type<+Variable> "=" Expression<+Variable> ";";

Declaration ::=
	| DeclarationType
	| DeclarationVariable
;



StatementExpression
	::= Expression<+Variable>? ";";

StatementAssignment
	::= Assignee "=" Expression<+Variable> ";";

Statement ::=
	| Declaration
	| StatementExpression
	| StatementAssignment
;



Goal ::= #x02 Statement* #x03;
