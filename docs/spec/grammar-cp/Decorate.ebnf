_KEYWORD_OTHER =:=
	// operator
		| "mutable"
		| "is"
		| "isnt"
		| "if"
		| "then"
		| "else"
	// storage
		| "type"
		| "let"
	// modifier
		| "unfixed"
;

Decorate(Word ::= _KEYWORD_OTHER) -> SemanticKey
	:= (SemanticKey[id=TokenWorth(_KEYWORD_OTHER)]);
Decorate(Word ::= KEYWORD_TYPE) -> SemanticKey
	:= (SemanticKey[id=TokenWorth(KEYWORD_TYPE)]);
Decorate(Word ::= KEYWORD_VALUE) -> SemanticKey
	:= (SemanticKey[id=TokenWorth(KEYWORD_VALUE)]);
Decorate(Word ::= IDENTIFIER) -> SemanticKey
	:= (SemanticKey[id=TokenWorth(IDENTIFIER)]);



Decorate(PrimitiveLiteral ::= KEYWORD_VALUE) -> SemanticConstant
	:= (SemanticConstant[value=KeywordValue(KEYWORD_VALUE)]);
Decorate(PrimitiveLiteral ::= INTEGER) -> SemanticConstant
	:= (SemanticConstant[value=Integer(TokenWorth(INTEGER))]);
Decorate(PrimitiveLiteral ::= FLOAT) -> SemanticConstant
	:= (SemanticConstant[value=Float(TokenWorth(FLOAT))]);
Decorate(PrimitiveLiteral ::= STRING) -> SemanticConstant
	:= (SemanticConstant[value=String(TokenWorth(STRING))]);



Decorate(EntryType<-Named><-Optional> ::= Type) -> SemanticItemType
	:= (SemanticItemType[optional=false] Decorate(Type));
Decorate(EntryType<-Named><+Optional> ::= "?:" Type) -> SemanticItemType
	:= (SemanticItemType[optional=true] Decorate(Type));
Decorate(EntryType<+Named><-Optional> ::= Word ":" Type) -> SemanticPropertyType
	:= (SemanticPropertyType[optional=false]
		Decorate(Word)
		Decorate(Type)
	);
Decorate(EntryType<+Named><+Optional> ::= Word "?:" Type) -> SemanticPropertyType
	:= (SemanticPropertyType[optional=true]
		Decorate(Word)
		Decorate(Type)
	);



Decorate(ItemsType ::= EntryType<-Named><-Optional># ","?) -> Sequence<SemanticItemType>
	:= ParseList(EntryType<-Named><-Optional>, SemanticItemType);
Decorate(ItemsType ::= EntryType<-Named><+Optional># ","?) -> Sequence<SemanticItemType>
	:= ParseList(EntryType<-Named><+Optional>, SemanticItemType);
Decorate(ItemsType ::= EntryType<-Named><-Optional># "," EntryType<-Named><+Optional># ","?) -> Sequence<SemanticItemType>
	:= [
		...ParseList(EntryType<-Named><-Optional>, SemanticItemType),
		...ParseList(EntryType<-Named><+Optional>, SemanticItemType),
	];



Decorate(PropertiesType ::= EntryType<+Named><-Optional># ","?) -> Sequence<SemanticPropertyType>
	:= ParseList(EntryType<+Named><-Optional>, SemanticPropertyType);
Decorate(PropertiesType ::= EntryType<+Named><+Optional># ","?) -> Sequence<SemanticPropertyType>
	:= ParseList(EntryType<+Named><+Optional>, SemanticPropertyType);



Decorate(TypeGrouped ::= "(" Type ")") -> SemanticType
	:= Decorate(Type);

Decorate(TypeTupleLiteral ::= "[" "]") -> SemanticTypeTuple
	:= (SemanticTypeTuple);
Decorate(TypeTupleLiteral ::= "[" ","? ItemsType "]") -> SemanticTypeTuple
	:= (SemanticTypeTuple
		...Decorate(ItemsType)
	);

Decorate(TypeRecordLiteral ::= "[" ","? PropertiesType "]") -> SemanticTypeRecord
	:= (SemanticTypeRecord
		...Decorate(PropertiesType)
	);

Decorate(TypeDictLiteral ::= "[" ":" Type "]") -> SemanticTypeDict
	:= (SemanticTypeDict
		Decorate(Type)
	);

Decorate(TypeMapLiteral ::= "{" Type__0 "->" Type__1 "}") -> SemanticTypeMap
	:= (SemanticTypeMap
		Decorate(Type__0)
		Decorate(Type__1)
	);

Decorate(GenericArguments ::= "<" ","? Type# ","? ">") -> Sequence<SemanticType>
	:= ParseList(Type, SemanticType);



Decorate(TypeUnit ::= KEYWORD_TYPE) -> SemanticTypeConstant
	:= (SemanticTypeConstant[value=KeywordType(KEYWORD_TYPE)]);
Decorate(TypeUnit ::= IDENTIFIER) -> SemanticTypeAlias
	:= (SemanticTypeAlias[id=TokenWorth(IDENTIFIER)]);
Decorate(TypeUnit ::= PrimitiveLiteral) -> SemanticTypeConstant
	:= (SemanticTypeConstant[value=ToType(Decorate(PrimitiveLiteral).value)]);
Decorate(TypeUnit ::= TypeGrouped) -> SemanticType
	:= Decorate(TypeGrouped);
Decorate(TypeUnit ::= TypeTupleLiteral) -> SemanticTypeTuple
	:= Decorate(TypeTupleLiteral);
Decorate(TypeUnit ::= TypeRecordLiteral) -> SemanticTypeRecord
	:= Decorate(TypeRecordLiteral);
Decorate(TypeUnit ::= TypeDictLiteral) -> SemanticTypeDict
	:= Decorate(TypeDictLiteral);
Decorate(TypeUnit ::= TypeMapLiteral) -> SemanticTypeMap
	:= Decorate(TypeMapLiteral);



Decorate(PropertyAccessType ::= "." INTEGER) -> SemanticIndexType
	:= (SemanticIndexType
		(SemanticTypeConstant[value=ToType(Integer(TokenWorth(INTEGER)))])
	);
Decorate(PropertyAccessType ::= "." Word) -> SemanticKey
	:= Decorate(Word);

Decorate(GenericCall ::= "." GenericArguments) -> Sequence<SemanticType>
	:= Decorate(GenericArguments);



Decorate(TypeCompound ::= TypeUnit) -> SemanticType
	:= Decorate(TypeUnit);
Decorate(TypeCompound ::= TypeCompound PropertyAccessType) -> SemanticTypeAccess
	:= (SemanticTypeAccess
		Decorate(TypeCompound)
		Decorate(PropertyAccessType)
	);
Decorate(TypeCompound ::= TypeCompound GenericCall) -> SemanticTypeCall
	:= (SemanticTypeCall
		Decorate(TypeCompound)
		...Decorate(GenericCall)
	);



Decorate(TypeUnarySymbol ::= TypeCompound) -> SemanticType
	:= Decorate(TypeCompound);
Decorate(TypeUnarySymbol ::= TypeUnarySymbol "?") -> SemanticTypeOperation
	:= (SemanticTypeOperation[operator=ORNULL]
		Decorate(TypeUnarySymbol)
	);
Decorate(TypeUnarySymbol ::= TypeUnarySymbol "!") -> SemanticTypeOperation
	:= (SemanticTypeOperation[operator=OREXCP]
		Decorate(TypeUnarySymbol)
	);
Decorate(TypeUnarySymbol ::= TypeUnarySymbol "[" "]") -> SemanticTypeList
	:= (SemanticTypeList[count=none]
		Decorate(TypeUnarySymbol)
	);
Decorate(TypeUnarySymbol ::= TypeUnarySymbol "[" INTEGER "]") -> SemanticTypeList
	:= (SemanticTypeList[count=TokenWorth(INTEGER)]
		Decorate(TypeUnarySymbol)
	);
Decorate(TypeUnarySymbol ::= TypeUnarySymbol "{" "}") -> SemanticTypeSet
	:= (SemanticTypeSet
		Decorate(TypeUnarySymbol)
	);



Decorate(TypeUnaryKeyword ::= TypeUnarySymbol) -> SemanticType
	:= Decorate(TypeUnarySymbol);
Decorate(TypeUnaryKeyword ::= "mutable" TypeUnaryKeyword) -> SemanticTypeOperation
	:= (SemanticTypeOperation[operator=MUTABLE]
		Decorate(TypeUnaryKeyword)
	);



Decorate(TypeIntersection ::= TypeUnarySymbol) -> SemanticType
	:= Decorate(TypeUnarySymbol);
Decorate(TypeIntersection ::= TypeIntersection "&" TypeUnaryKeyword) -> SemanticTypeOperation
	:= (SemanticTypeOperation[operator=AND]
		Decorate(TypeIntersection)
		Decorate(TypeUnaryKeyword)
	);



Decorate(TypeUnion ::= TypeIntersection) -> SemanticType
	:= Decorate(TypeIntersection);
Decorate(TypeUnion ::= TypeUnion "|" TypeIntersection) -> SemanticTypeOperation
	:= (SemanticTypeOperation[operator=OR]
		Decorate(TypeUnion)
		Decorate(TypeIntersection)
	);



Decorate(Type ::= TypeUnion) -> SemanticType
	:= Decorate(TypeUnion);



Decorate(StringTemplate<Variable> ::= TEMPLATE_FULL) -> SemanticTemplate
	:= (SemanticTemplate
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_FULL))])
	);
Decorate(StringTemplate<Variable> ::= TEMPLATE_HEAD TEMPLATE_TAIL) -> SemanticTemplate
	:= (SemanticTemplate
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_HEAD))])
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_TAIL))])
	);
Decorate(StringTemplate<Variable> ::= TEMPLATE_HEAD Expression<?Variable> TEMPLATE_TAIL) -> SemanticTemplate
	:= (SemanticTemplate
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_HEAD))])
		Decorate(Expression<?Variable>)
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_TAIL))])
	);
Decorate(StringTemplate<Variable> ::= TEMPLATE_HEAD StringTemplate__0__List<?Variable> TEMPLATE_TAIL) -> SemanticTemplate
	:= (SemanticTemplate
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_HEAD))])
		...Decorate(StringTemplate__0__List<?Variable>)
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_TAIL))])
	);
Decorate(StringTemplate<Variable> ::= TEMPLATE_HEAD Expression<?Variable> StringTemplate__0__List<?Variable> TEMPLATE_TAIL) -> SemanticTemplate
	:= (SemanticTemplate
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_HEAD))])
		Decorate(Expression<?Variable>)
		...Decorate(StringTemplate__0__List<?Variable>)
		(SemanticConstant[value=String(TokenWorth(TEMPLATE_TAIL))])
	);

	Decorate(StringTemplate__0__List<Variable> ::= TEMPLATE_MIDDLE) -> Vector<SemanticConstant>
		:= [SemanticConstant[value=String(TokenWorth(TEMPLATE_MIDDLE))]];
	Decorate(StringTemplate__0__List<Variable> ::= TEMPLATE_MIDDLE Expression<?Variable>) -> Vector<SemanticConstant, SemanticExpression>
		:= [
			(SemanticConstant[value=String(TokenWorth(TEMPLATE_MIDDLE))]),
			Decorate(Expression<?Variable>),
		];
	Decorate(StringTemplate__0__List<Variable> ::= StringTemplate__0__List<?Variable> TEMPLATE_MIDDLE) -> Sequence<...Vector<SemanticConstant, SemanticExpression?>>
		:= [
			...Decorate(StringTemplate__0__List<?Variable>),
			(SemanticConstant[value=String(TokenWorth(TEMPLATE_MIDDLE))]),
		];
	Decorate(StringTemplate__0__List<Variable> ::= StringTemplate__0__List<?Variable> TEMPLATE_MIDDLE Expression<?Variable>) -> Sequence<...Vector<SemanticConstant, SemanticExpression?>>
		:= [
			...Decorate(StringTemplate__0__List<?Variable>),
			(SemanticConstant[value=String(TokenWorth(TEMPLATE_MIDDLE))]),
			Decorate(Expression<?Variable>),
		];



Decorate(Property<Variable> ::= Word "=" Expression<?Variable>) -> SemanticProperty
	:= (SemanticProperty
		Decorate(Word)
		Decorate(Expression<?Variable>)
	);

Decorate(Case ::= Expression<+Variable> "->" Expression<+Variable>) -> SemanticCase
	:= (SemanticCase
		Decorate(Expression<+Variable>)
		Decorate(Expression<+Variable>)
	);



Decorate(ExpressionGrouped<Variable> ::= "(" Expression<?Variable> ")") -> SemanticExpression
	:= Decorate(Expression<?Variable>);

Decorate(TupleLiteral<-Variable> ::= "\[" "]") -> SemanticTuple
	:= (SemanticTuple[isRef=false]);
Decorate(TupleLiteral<+Variable> ::= "[" "]") -> SemanticTuple
	:= (SemanticTuple[isRef=true]);
Decorate(TupleLiteral<-Variable> ::= "\[" ","? Expression<?Variable># ","? "]") -> SemanticTuple
	:= (SemanticTuple[isRef=false]
		...ParseList(Expression<?Variable>, SemanticExpression)
	);
Decorate(TupleLiteral<+Variable> ::= "[" ","? Expression<?Variable># ","? "]") -> SemanticTuple
	:= (SemanticTuple[isRef=true]
		...ParseList(Expression<?Variable>, SemanticExpression)
	);

Decorate(RecordLiteral<-Variable> ::= "\[" ","? Property<?Variable># ","? "]") -> SemanticRecord
	:= (SemanticRecord[isRef=false]
		...ParseList(Property<?Variable>, SemanticProperty)
	);
Decorate(RecordLiteral<+Variable> ::= "[" ","? Property<?Variable># ","? "]") -> SemanticRecord
	:= (SemanticRecord[isRef=true]
		...ParseList(Property<?Variable>, SemanticProperty)
	);

Decorate(SetLiteral ::= "{" ","? Expression<+Variable># ","? "}") -> SemanticSet
	:= (SemanticSet
		...ParseList(Expression<+Variable>, SemanticExpression)
	);

Decorate(MapLiteral ::= "{" ","? Case# ","? "}") -> SemanticMap
	:= (SemanticMap
		...ParseList(Case, SemanticCase)
	);

Decorate(FunctionArguments ::= "(" ( ","? Expression<+Variable># ","? )? ")") -> Sequence<SemanticExpression>
	:= ParseList(Expression<+Variable>, SemanticExpression);



Decorate(ExpressionUnit<+Variable> ::= IDENTIFIER) -> SemanticVariable
	:= (SemanticVariable[id=TokenWorth(IDENTIFIER)]);
Decorate(ExpressionUnit<Variable> ::= PrimitiveLiteral) -> SemanticConstant
	:= Decorate(PrimitiveLiteral);
Decorate(ExpressionUnit<Variable> ::= StringTemplate<?Variable>) -> SemanticTemplate
	:= Decorate(StringTemplate<?Variable>);
Decorate(ExpressionUnit<Variable> ::= ExpressionGrouped<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionGrouped<?Variable>);
Decorate(ExpressionUnit<Variable> ::= TupleLiteral<-Variable>) -> SemanticTuple
	:= Decorate(TupleLiteral<-Variable>);
Decorate(ExpressionUnit<Variable> ::= RecordLiteral<-Variable>) -> SemanticRecord
	:= Decorate(RecordLiteral<-Variable>);
Decorate(ExpressionUnit<+Variable> ::= TupleLiteral<?Variable>) -> SemanticTuple
	:= Decorate(TupleLiteral<?Variable>);
Decorate(ExpressionUnit<+Variable> ::= RecordLiteral<?Variable>) -> SemanticRecord
	:= Decorate(RecordLiteral<?Variable>);
Decorate(ExpressionUnit<+Variable> ::= SetLiteral) -> SemanticSet
	:= Decorate(SetLiteral);
Decorate(ExpressionUnit<+Variable> ::= MapLiteral) -> SemanticMap
	:= Decorate(MapLiteral);



Decorate(PropertyAccess<Variable> ::= ("." | "?." | "!.") INTEGER) -> SemanticIndex
	:= (SemanticIndex
		(SemanticConstant[value=Integer(TokenWorth(INTEGER))])
	);
Decorate(PropertyAccess<Variable> ::= ("." | "?." | "!.") Word) -> SemanticKey
	:= Decorate(Word);
Decorate(PropertyAccess<Variable> ::= ("." | "?." | "!.") "[" Expression<?Variable> "]") -> SemanticExpression
	:= Decorate(Expression<?Variable>);

Decorate(PropertyAssign ::= "." INTEGER) -> SemanticIndex
	:= (SemanticIndex
		(SemanticConstant[value=Integer(TokenWorth(INTEGER))])
	);
Decorate(PropertyAssign ::= "." Word) -> SemanticKey
	:= Decorate(Word);
Decorate(PropertyAssign ::= "." "[" Expression<+Variable> "]") -> SemanticExpression
	:= Decorate(Expression<+Variable>);

Decorate(FunctionCall ::= "." FunctionArguments) -> Vector<Sequence<SemanticType>, Sequence<SemanticExpression>>
	:= [
		[],
		Decorate(FunctionArguments),
	];
Decorate(FunctionCall ::= "." GenericArguments FunctionArguments) -> Vector<Sequence<SemanticType>, Sequence<SemanticExpression>>
	:= [
		Decorate(GenericArguments),
		Decorate(FunctionArguments),
	];



Decorate(ExpressionCompound<Variable> ::= ExpressionUnit<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionUnit<?Variable>);
Decorate(ExpressionCompound<Variable> ::= ExpressionCompound<?Variable> PropertyAccess<?Variable>) -> SemanticAccess
	:= (SemanticAccess[kind=AccessKind(PropertyAccess<?Variable>)]
		Decorate(ExpressionCompound<?Variable>)
		Decorate(PropertyAccess<?Variable>)
	);
Decorate(ExpressionCompound<+Variable> ::= ExpressionCompound<?Variable> FunctionCall) -> SemanticCall
	:= (SemanticCall
		Decorate(ExpressionCompound<?Variable>)
		...(...Decorate(FunctionCall))
	);



Decorate(Assignee ::= IDENTIFIER) -> SemanticVariable
	:= (SemanticVariable[id=TokenWorth(IDENTIFIER)]);
Decorate(Assignee ::= ExpressionCompound<+Variable> PropertyAssign) -> SemanticAccess
	:= (SemanticAccess[kind=NORMAL]
		Decorate(ExpressionCompound<+Variable>)
		Decorate(PropertyAssign)
	);



Decorate(ExpressionUnarySymbol<Variable> ::= ExpressionCompound<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionCompound<?Variable>);
Decorate(ExpressionUnarySymbol<Variable> ::= "!" ExpressionUnarySymbol<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		Decorate(ExpressionUnarySymbol<?Variable>)
	);
Decorate(ExpressionUnarySymbol<Variable> ::= "?" ExpressionUnarySymbol<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=EMP]
		Decorate(ExpressionUnarySymbol<?Variable>)
	);
Decorate(ExpressionUnarySymbol<Variable> ::= "+" ExpressionUnarySymbol<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionUnarySymbol<?Variable>);
Decorate(ExpressionUnarySymbol<Variable> ::= "-" ExpressionUnarySymbol<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NEG]
		Decorate(ExpressionUnarySymbol<?Variable>)
	);



Decorate(ExpressionExponential<Variable> ::= ExpressionUnarySymbol<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionUnarySymbol<?Variable>);
Decorate(ExpressionExponential<Variable> ::= ExpressionUnarySymbol<?Variable> "^" ExpressionExponential<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=EXP]
		Decorate(ExpressionUnarySymbol<?Variable>)
		Decorate(ExpressionExponential<?Variable>)
	);



Decorate(ExpressionMultiplicative<Variable> ::= ExpressionExponential<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionExponential<?Variable>);
Decorate(ExpressionMultiplicative<Variable> ::= ExpressionMultiplicative<?Variable> "*" ExpressionExponential<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=MUL]
		Decorate(ExpressionMultiplicative<?Variable>)
		Decorate(ExpressionExponential<?Variable>)
	);
Decorate(ExpressionMultiplicative<Variable> ::= ExpressionMultiplicative<?Variable> "/" ExpressionExponential<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=DIV]
		Decorate(ExpressionMultiplicative<?Variable>)
		Decorate(ExpressionExponential<?Variable>)
	);



Decorate(ExpressionAdditive<Variable> ::= ExpressionMultiplicative<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionMultiplicative<?Variable>);
Decorate(ExpressionAdditive<Variable> ::= ExpressionAdditive<?Variable> "+" ExpressionMultiplicative<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=ADD]
		Decorate(ExpressionAdditive<?Variable>)
		Decorate(ExpressionMultiplicative<?Variable>)
	);
Decorate(ExpressionAdditive<Variable> ::= ExpressionAdditive<?Variable> "-" ExpressionMultiplicative<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=ADD]
		Decorate(ExpressionAdditive<?Variable>)
		(SemanticOperation[operator=NEG] Decorate(ExpressionMultiplicative<?Variable>))
	);



Decorate(ExpressionComparative<Variable> ::= ExpressionAdditive<?Variable>) -> SemanticOperation
	:= Decorate(ExpressionAdditive<?Variable>);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> "<" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=LT]
		Decorate(ExpressionComparative<?Variable>)
		Decorate(ExpressionAdditive<?Variable>)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> ">" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=GT]
		Decorate(ExpressionComparative<?Variable>)
		Decorate(ExpressionAdditive<?Variable>)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> "<=" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=LE]
		Decorate(ExpressionComparative<?Variable>)
		Decorate(ExpressionAdditive<?Variable>)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> ">=" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=GE]
		Decorate(ExpressionComparative<?Variable>)
		Decorate(ExpressionAdditive<?Variable>)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> "!<" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=LT]
			Decorate(ExpressionComparative<?Variable>)
			Decorate(ExpressionAdditive<?Variable>)
		)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> "!>" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=GT]
			Decorate(ExpressionComparative<?Variable>)
			Decorate(ExpressionAdditive<?Variable>)
		)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> "is" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=IS]
		Decorate(ExpressionComparative<?Variable>)
		Decorate(ExpressionAdditive<?Variable>)
	);
Decorate(ExpressionComparative<Variable> ::= ExpressionComparative<?Variable> "isnt" ExpressionAdditive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=IS]
			Decorate(ExpressionComparative<?Variable>)
			Decorate(ExpressionAdditive<?Variable>)
		)
	);



Decorate(ExpressionEquality<Variable> ::= ExpressionComparative<?Variable>) -> SemanticOperation
	:= Decorate(ExpressionComparative<?Variable>);
Decorate(ExpressionEquality<Variable> ::= ExpressionEquality<?Variable> "===" ExpressionComparative<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=ID]
		Decorate(ExpressionEquality<?Variable>)
		Decorate(ExpressionComparative<?Variable>)
	);
Decorate(ExpressionEquality<Variable> ::= ExpressionEquality<?Variable> "!==" ExpressionComparative<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=ID]
			Decorate(ExpressionEquality<?Variable>)
			Decorate(ExpressionComparative<?Variable>)
		)
	);
Decorate(ExpressionEquality<Variable> ::= ExpressionEquality<?Variable> "==" ExpressionComparative<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=EQ]
		Decorate(ExpressionEquality<?Variable>)
		Decorate(ExpressionComparative<?Variable>)
	);
Decorate(ExpressionEquality<Variable> ::= ExpressionEquality<?Variable> "!=" ExpressionComparative<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=EQ]
			Decorate(ExpressionEquality<?Variable>)
			Decorate(ExpressionComparative<?Variable>)
		)
	);



Decorate(ExpressionConjunctive<Variable> ::= ExpressionEquality<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionEquality<?Variable>);
Decorate(ExpressionConjunctive<Variable> ::= ExpressionConjunctive<?Variable> "&&" ExpressionEquality<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=AND]
		Decorate(ExpressionConjunctive<?Variable>)
		Decorate(ExpressionEquality<?Variable>)
	);
Decorate(ExpressionConjunctive<Variable> ::= ExpressionConjunctive<?Variable> "!&" ExpressionEquality<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=AND]
			Decorate(ExpressionConjunctive<?Variable>)
			Decorate(ExpressionEquality<?Variable>)
		)
	);



Decorate(ExpressionDisjunctive<Variable> ::= ExpressionConjunctive<?Variable>) -> SemanticOperation
	:= Decorate(ExpressionConjunctive<?Variable>);
Decorate(ExpressionDisjunctive<Variable> ::= ExpressionDisjunctive<?Variable> "||" ExpressionConjunctive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=OR]
		Decorate(ExpressionDisjunctive<?Variable>)
		Decorate(ExpressionConjunctive<?Variable>)
	);
Decorate(ExpressionDisjunctive<Variable> ::= ExpressionDisjunctive<?Variable> "!|" ExpressionConjunctive<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=NOT]
		(SemanticOperation[operator=OR]
			Decorate(ExpressionDisjunctive<?Variable>)
			Decorate(ExpressionConjunctive<?Variable>)
		)
	);



Decorate(ExpressionConditional<Variable> ::= "if" Expression__0<?Variable> "then" Expression__1<?Variable> "else" Expression__2<?Variable>) -> SemanticOperation
	:= (SemanticOperation[operator=COND]
		Decorate(Expression__0<?Variable>)
		Decorate(Expression__1<?Variable>)
		Decorate(Expression__2<?Variable>)
	);



Decorate(Expression<Variable> ::= ExpressionDisjunctive<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionDisjunctive<?Variable>);
Decorate(Expression<Variable> ::= ExpressionConditional<?Variable>) -> SemanticExpression
	:= Decorate(ExpressionConditional<?Variable>);



Decorate(DeclarationType ::= "type" IDENTIFIER "=" Type ";") -> SemanticDeclarationType
	:= (SemanticDeclarationType
		(SemanticTypeAlias[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
	);



Decorate(DeclarationVariable ::= "let" IDENTIFIER ":" Type "=" Expression<+Variable> ";") -> SemanticDeclarationVariable
	:= (SemanticDeclarationVariable[unfixed=false]
		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
		Decorate(Expression<+Variable>)
	);
Decorate(DeclarationVariable ::= "let" "unfixed" IDENTIFIER ":" Type "=" Expression<+Variable> ";") -> SemanticDeclarationVariable
	:= (SemanticDeclarationVariable[unfixed=true]
		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
		Decorate(Expression<+Variable>)
	);



Decorate(Declaration ::= DeclarationType) -> SemanticDeclarationType
	:= Decorate(DeclarationType);
Decorate(Declaration ::= DeclarationVariable) -> SemanticDeclarationVariable
	:= Decorate(DeclarationVariable);



Decorate(StatementExpression ::= ";") -> SemanticStatementExpression
	:= (SemanticStatementExpression);
Decorate(StatementExpression ::= Expression<+Variable> ";") -> SemanticStatementExpression
	:= (SemanticStatementExpression Decorate(Expression<+Variable>));



Decorate(StatementAssignment ::= Assignee "=" Expression<+Variable> ";") -> SemanticAssignment
	:= (SemanticAssignment
		Decorate(Assignee)
		Decorate(Expression<+Variable>)
	);



Decorate(Statement ::= Declaration) -> SemanticDeclaration
	:= Decorate(Declaration);
Decorate(Statement ::= StatementExpression) -> SemanticStatementExpression
	:= Decorate(StatementExpression);
Decorate(Statement ::= StatementAssignment) -> SemanticAssignment
	:= Decorate(StatementAssignment);



Decorate(Goal ::= #x02 #x03) -> SemanticGoal
	:= (SemanticGoal);
Decorate(Goal ::= #x02 Statement+ #x03) -> SemanticGoal
	:= (SemanticGoal
		...ParseList(Statement, SemanticStatement)
	);



ParseList(ParseNode, ASTNode)(ParseNode__List ::= ParseNode) -> Sequence<ASTNode>
	:= [Decorate(ParseNode)];
ParseList(ParseNode, ASTNode)(ParseNode__List ::= ParseNode__List ","? ParseNode) -> Sequence<ASTNode>
	:= [
		...Decorate(ParseNode__List),
		Decorate(ParseNode),
	];



AccessKind(PropertyAccess<Variable> ::= "."  (INTEGER | Word | "[" Expression<?Variable> "]")) -> NORMAL   := NORMAL;
AccessKind(PropertyAccess<Variable> ::= "?." (INTEGER | Word | "[" Expression<?Variable> "]")) -> OPTIONAL := OPTIONAL;
AccessKind(PropertyAccess<Variable> ::= "!." (INTEGER | Word | "[" Expression<?Variable> "]")) -> CLAIM    := CLAIM;
